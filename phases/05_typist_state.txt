# **Phase 4: Rigorously Define Types **

Your role in this phase is to take the MVP features, fundamental inputs, and fundamental state defined for the project in previous phases. and convert them into more rigorous types that will form the basis for engineering the project. In the interest of functional programming principles and minimalism, your goal should be to define simple, minimal types with no extra data or fields if they could otherwise be derived from existing fields.

When defining types throughout this phase, follow the following guidelines:
- Avoid usage of strings whenever possible, unless the type is truly meant to be defined as an arbitrary string. Favor enums when what could otherwise be a string has a finite number of values.

Step 1: Initial Typed State Components
- The state of the program will be a tuple of the state components. An initial list of fundamental state components was previously determined, which we will refine throughout this phase. In this step, we should more rigorously define the state components' types.
- We will use Typescript to do this.  For each State Component, create a typescript type to express the component.
- Emphasize minimalism and elegance in this step. Do not include extra data or fields in the type if you can avoid it.
- If you need to define subtypes or helper types, do so separately at the bottom. Only give a single type in the component list.
Deliverable: Typescript types for each component. Format:
# Fundamental State Component Types
1. **Component 1**
```typescript
type ...
```
2. **Component 2**
...
# Shared subtypes
[additional types and enums used by the above]

Step 2: Identify unneccesary fields
- In this step, your goal is to help identify unneccesary fields in the initial fundamental state component types. Because we want to follow minimization and functional programming principles, certain fields initially added above may not be needed.
- For each field of each type defined above, list an argument against requiring that field existing in the type. In this step, keep an open mind and ALWAYS come up with an argument, no matter how weak it might seem at face value. In future steps, we will evaluate the validity of the argument. In this step, we want to get all ideas out there.
    - The most common argument for exclusion is that other fields in the state are sufficient to recover whatever information this field conveys. If forming this argument, explicitly state what other state components or fields the information can be recovered from, and include basic sketch of how those specific components and fields could be used to reconstruct the relevant information.
    - In this step, the argument can not involve modifying the meaning or intended use of existing fundamental state components. It should only involve utilizing those fields and state components to produce the information conveyed by the field being argued for elimination.
    - Do NOT include any commentary on the feasibility of the argument, just state the most likely way this field could be eliminated. Argue about HOW this field could be eliminated, not the implications of doing so on performance, clarity, etc.
    - Do NOT propose modifying or adding other components or fields to the state. Our goal is to find a way to strictly reduce the number of fields, not increase them.

Deliverable format:
# Arguments for Fundamental State Component Field Removal
1. **Fundamental State 1**
    a. **Fundamental State 1 Field 1**: [argument for exclusion]
    b. **Fundamental State 1 Field 2**: [argument for exclusion]
    ...
2. **Fundamental State 2**
    ...
...


Before you begin, here is the relevant output from the previous phases, which defined an overview for the project, the set of MVP features, the program inputs, and the program's fundamental state components:

A brief description of the project:
{overview}

A list of the key MVP features for the project:
{features}

The fundamental inputs to the project's program:
{fundamental_inputs}

The fundamental state components of the project's program which the inputs will modify:
{refined_state}

With that context, you should be ready to execute this phase!
