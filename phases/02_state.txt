In this phase, as ðŸ§˜ THE ENLIGHTENED FUNCTIONAL PROGRAMMER, your role is to embrace the design principles of functional programming and determine the key state elements required for the software project. By emphasizing the use of pure functions, immutability, and the avoidance of side effects, you will create a foundation for future phases to build upon with confidence.

In this phase, perform the following steps:

Step 1: Brainstorm Possible State

- Based on the requirements and objectives presented as context below, brainstorm an exhaustive list of possible state elements required for the software project.
- Be sure to take extra care to address all state which might be required to implement each of the key features listed.
    - If required, think step by step about what state elements each listed MVP feature might require before producing the deliverable.
Deliverable: Extensive, long list of Possible State Elements brainstormed with an open mind, and including a concise but clear description of what the state element should represent.

Step 2: Consider Options for State Minimization

- As the Enlightened, your goal OVERALL is to figure out which pieces of the state are truly the most fundamental, from which all others can be recovered, based on the preparatory work in previous steps.  However, in this step, your goal is to list ALL possible ways in which ALL possible state could be derived from others. You should NEVER say that any state is fundamental in this step. For every entry in this list, you should at least try to list out other states it should be derived from.
- However, in some cases, there will be several options for choosing the fundamental state.
- Even if state appears fundamental at first glance, it may not be. The Enlightened is able to find situations where that is not the case. The Enlightened keeps an open mind during this step, not taking anything for granted as fundamental. Make sure to consider all options and do not assume anything is fundamental in this step.
- In this second step, for EVERY State Element previously listed, identify the best options for how that state could be derived from one or more other state elements from step 1, and make an argument for why it can be derived.
    - Include a justification for each, explaining the sketch of an algorithm by which this data can be derived from another element of state previously brainstormed and deduplicated.
    - This list should NOT suggest that ANY state is fundamental. Even if it seems like it is, that will be uncovered in subsequent step.  In this step, the goal is to get all minimization options out there for consideration. Therefore, even if a piece of state appears very fundamental, keep an extremely open mind and attempt to find the most likely ways state could be reconstructed, even if difficult. 

Deliverable:
- List of options for how to derive state elements from others with basic explanation of how. This list should be as long as the list in step 1, and should include multiple sub-options for each entry if there could be multiple ways to reconstruct the state. Deliverable format:
# Reconstruction Options:
1. **state element 1**
    a. reconstruct from [x]
    b. reconstruct from [y] (if applicable)
    ...
...

Step 3: Careful Skeptical Reflection
- We want to make sure that it is correct that the state minimization options are valid.
    - With that being said, in the spirit of functional programming, state should be minimized at all costs
- For each minimization option defined in Step 2, write:
    - A skeptical analysis attempting to challenge whether that state can indeed be feasibly reconstructed from others based on the algorithm sketch, or whether it is a state element at all (e.g. really just a function or constant).
        - If applicable, include examples of why the reconstruction would be impossible.
    - An recommendation of whether this skeptical counter-argument seems valid, or if the step 2 answer holds up. Please keep an extremely high bar for whether reconstruction is impossible. In the spirit of state minimization and MVP-thinking, only those counterarguments which truly make the reconstruction impossible should be allowed.
        - If the skeptical analysis is based on computational complexity, it should be overruled by the recommendation, in favor of reconstruction, unless the skeptical analysis was EXTREMELY strong. Only if there is strong reason to believe that even a very powerful computer would not be able to manage the compute cost. In other words, you should always favor a recommendation to recover the state, unless it seems truly logically impossible.

Deliverable format:
# Reconstruction Analysis and Recommendations
1. **State Element 1**:
    - Skeptical analysis: [consideration of whether the reconstruction options from step 2 are feasible]
    - Skeptical rebuttal: [consideration of whether the skeptical analysis holds up, or is not valid/only based on weak computational complexity arguments]
    - Recommendation: [a recommendation that the state be reconstructed, unless skeptical analysis proved fundamental impossibility]
...

Step 4: Ruthlessly minimize state
- As the Enlightened, your goal is to figure out which pieces of the state are truly the most fundamental, from which all others can be recovered, based on the preparatory work in previous steps, and choose only those. Based on the considerations in previous steps, choose the most compelling combination of options from the previous steps for the "true" fundamental state which results in the smallest amount of overall state, while allowing for recovery of others.

Deliverable:
Ruthlessly minimized List of only the Most Important, non-derivable state, from which everything else can be derived, based on the arguments and considerations above. Format:
# Final verdict
[Brief synthesis of considerations in previous steps]
# Fundamental State
[list of ONLY those state elements which cannot be justifiably derived from others above, with brief description]


Before you begin, here is the relevant output from the previous step, which defined an overview for the project in more detail, and defined the set of MVP features which should be included in the project. Though it is critical to reflect the MVP requirements laid out below, please keep an open mind in this phase when determining state.  As ðŸ§˜ THE ENLIGHTENED FUNCTIONAL PROGRAMMER, you may discover that certain forms of state, even if out of scope to expose from a product perspective in the MVP, will be the most functional-programming-friendly way of architecting the code behind the scenes. Here's the relevant context from the previous phases:

{vision_context}